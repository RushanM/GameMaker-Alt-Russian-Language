# События отрисовки

[*Оригинальная статья.*](https://manual.gamemaker.io/beta/en/index.htm#t=The_Asset_Editors%2FObject_Properties%2FDraw_Events.htm)

---

<p align="center">
    <img src="https://github.com/RushanM/GameMaker-Alt-Russian-Language/blob/main/Ассеты/Документация. События отрисовки. 1.png?raw=true">
</p>

События категории **«При отрисовке»** определяют, что именно вы видите на экране при запуске игры. Они разделены на несколько отдельных подтипов, чтобы упростить работу с разными задачами по отрисовке. Ниже представлена схема, показывающая порядок выполнения этих событий:

<p align="center">
    <img src="https://github.com/RushanM/GameMaker-Alt-Russian-Language/blob/main/Ассеты/Документация. События отрисовки. 2.png?raw=true">
</p>

Обычное событие «При отрисовке» делится на три подтипа: **«При начале отрисовки»**, стандартное **«При отрисовке»** и **«В конце отрисовки»**. В большинстве случаев вы будете использовать стандартное событие «При отрисовке». При этом важно помнить, что у всех экземпляров объектов в комнате событие «При отрисовке» (или его подтипы) будет вызываться каждый кадр («шаг») игры, при условии, что у экземпляра установлен флаг [**`Видим`**](https://manual.gamemaker.io/beta/en/GameMaker_Language/GML_Reference/Asset_Management/Instances/Instance_Variables/visible.htm) со значением `true`. Даже если вы не прописали в событии «При отрисовке» никакого кода (ни действий, ни скриптов), *но при этом объект имеет прикреплённый спрайт, GameMaker всё равно будет вызывать событие «При отрисовке» и отображать этот спрайт*. Причина в том, что у GameMaker два способа отрисовывать вещи в событии отрисовки:

* **стандартная отрисовка**. Если в объекте задан спрайт, но в событии «При отрисовке» нет ни кода, ни действий, GameMaker автоматически отрисует этот спрайт (или ничего не отрисует, если спрайт не назначен). При этом любые изменения, внесённые в других событиях (например, изменения `image_xscale`, `image_yscale`, `sprite_index`, `image_blend` и т. п.), будут учтены;
* **пользовательская отрисовка**. Если в событии «При отрисовке» присутствует код или действия, вы тем самым указываете GameMaker: «Я сам хочу указывать, что именно должно отрисовываться для экземпляров этого объекта». Это полностью отключает стандартную отрисовку спрайта. Например, если в событии «При отрисовке» вы написали код для отображения текста, но не указали, что нужно отрисовать и спрайт, то на экране будет только текст.

Ниже описаны остальные события из категории «При отрисовке».

<details>
<summary><h2>«При начале отрисовки» и «В конце отрисовки»</h2></summary>

Помимо стандартного события «При отрисовке», существуют также **«При начале отрисовки»** и **«В конце отрисовки»**. Они работают так же, как и обычное событие «При отрисовке» (то есть будут выполняться каждый кадр игры на всех портах просмотра), но при этом они не отрисовывают ничего по умолчанию (не имеют «стандартной отрисовки»), если вы не добавили их явно в объект, а также они всегда будут выполняться **до** или **после** стандартного «При отрисовке». Так что в ходе каждого кадра игры порядок всегда будет оставаться такой: «При начале отрисовки» → «При отрисовке» → «В конце отрисовки» (для всех экземпляров).

Таким образом, вы можете, к примеру, в событии «При начале отрисовки» одного экземпляра установить какие-то параметры отрисовки, и будьте уверены, что все экземпляры со стандартным «При отрисовке» или «В конце отрисовки» отрисуют свои объекты с учётом уже установленных параметров. Аналогично, событие «В конце отрисовки» позволит вам отрисовать что-то поверх всего, что уже было выведено в «При отрисовке».

### Важные замечания по работе с отрисовкой

* событие «При отрисовке» — одно из самых «тяжёлых» с точки зрения вычислительной нагрузки. Поэтому нежелательно выполнять в нём сложные расчёты. Лучше оставить его только для отрисовки, а логику или большие объёмы кода выносить в другие события («Каждый кадр», отложки и т. д.);
* если параметр «Видим» объекта выключен, **все события отрисовки** (кроме **«При изменении размера окна»**) **для экземпляров этого объекта пропускаются**. То есть код в «При отрисовке», «При начале отрисовки», «В конце отрисовки» и т. п. не будет выполняться;
* то, что вы рисуете, никак не влияет на систему столкновений (традиционную или физическую). Столкновения определяются свойствами объекта и его спрайтом (или маской).

</details>

<details>
<summary><h2>«При отрисовке слоя интерфейса»</h2></summary>

Событие «При отрисовке слоя интерфейса» (и его подтипы «При начале отрисовке слоя интерфейса» и «В конце отрисовки слоя интерфейса») также относятся к категории «При отрисовке», но предназначены для отрисовки элементов *интерфейса*, не зависящих от позиции или масштаба камеры. Это значит, что вы можете отрисовывать элементы *пользовательского интерфейса* независимо от координат объекта в комнате или от текущих параметров вида камеры.

При отрисовке в этих событиях координаты всегда начинаются с (0,0) в левом верхнем углу **поверхности приложения** (или окна), а масштаб по умолчанию 1:1 соответствует размеру поверхности приложения. Глубина между экземплярами сохраняется так же, как и в обычных событиях «При отрисовке»:

1. Сначала выполняется **«При начале отрисовки слоя интерфейса»** для всех экземпляров.
2. Затем **«При отрисовке слоя интерфейса»**.
3. И в конце **«В конце отрисовки слоя интерфейса»**.

Таким образом, вы можете быть уверены, что объекты, рисующиеся в **«При начале отрисовки слоя интерфейса»**, будут отображены **под** тем, что нарисовано в **«При отрисовке слоя интерфейса»** и **«В конце отрисовки слоя интерфейса»**.

Если у вас нет обычного события «При отрисовке», но есть событие «При отрисовке слоя интерфейса», GameMaker по умолчанию всё равно будет отображать спрайт экземпляра (если он назначен).

По отношению к остальным событиям отрисовки события «При отрисовке слоя интерфейса» всегда отрисовываются **поверх** того, что было выведено в обычных событиях «При отрисовке». Если у экземпляра есть событие «При отрисовке слоя интерфейса», а у другого экземпляра (на более «высоком» слое) есть только стандартное «При отрисовке», элемент интерфейса первого экземпляра всё равно будет отрисован поверх второго.

> **Примечание:** по умолчанию в «При отрисовке слоя интерфейса» координаты соответствуют размеру поверхности приложения, который обычно равен размеру комнаты или вида. Если в [**настройках игры**](https://manual.gamemaker.io/beta/en/Settings/Game_Options.htm) включена **коррекция соотношения сторон**, на некоторых экранах могут появляться чёрные полосы, и по умолчанию интерфейс не рисуется поверх них. Это можно отключить с помощью функции [**`display_set_gui_maximise`**](https://manual.gamemaker.io/beta/en/GameMaker_Language/GML_Reference/Cameras_And_Display/display_set_gui_maximise.htm), а также можно задать фиксированный размер интерфейса через [**`display_set_gui_size`**](https://manual.gamemaker.io/beta/en/GameMaker_Language/GML_Reference/Cameras_And_Display/display_set_gui_size.htm), чтобы он автоматически масштабировался под нужные размеры.

</details>

<details>
<summary><h2>«Перед отрисовкой» и «После отрисовки»</h2></summary>

События **«Перед отрисовкой»** и **«После отрисовки»** тоже относятся к категории «При отрисовке,» но **отрисовывают напрямую в буфер дисплея**, соответствующий суммарному пространству экрана для всех в данный момент видимых портов просмотра или размеру окна, если используется лишь один порт просмотра или вообще не используется.

<p align="center">
    <img src="https://github.com/RushanM/GameMaker-Alt-Russian-Language/blob/main/Ассеты/Документация. События отрисовки. 3.png?raw=true">
</p>

Так что, если вы используете события **«Перед отрисовкой»** и **«После отрисовки»**, вы производите отрисовку на полноэкранную цель рендеринга (буфер дисплея), который будет того же размера, что и окно, и будет попытаться вместить все имеющиеся на ней порты просмотра. Если порты просмотра не включены, она просто подстроится под размер окна.

Событие «Перед отрисовкой» вызывается **до** всех остальных событий отрисовки. Здесь вы можете задавать параметры отрисовки или выводить что-то без учёта портов просмотра или слоя интерфейса (размер интерфейса может совпадать с буфером дисплея, а может и отличаться, поскольку его разрешение можно установить в коде).

Важно отметить, что «Перед отрисовкой» происходит до очистки буфера дисплея при стандартной отрисовкой. Это значит, что если в [**редакторе комнаты**](https://manual.gamemaker.io/beta/en/The_Asset_Editors/Rooms.htm) не отключена очистка видов, всё, что вы пропишите для отрисовки в «Перед отрисовкой», будет стёрто при первой отрисовке порта просмотра. Если вы хотите, чтобы через порты просмотра был виден фон, или вовсе не используете порты просмотра, необходимо также задать фону альфа-значение 0 в [**редакторе комнаты**](https://manual.gamemaker.io/beta/en/The_Asset_Editors/Rooms.htm).

> **Примечание:** если вы отключите очистку экрана, то в буфере могут оставаться артефакты с предыдущих кадров. Их можно убрать вручную с помощью [**`draw_clear_alpha`**](https://manual.gamemaker.io/beta/en/GameMaker_Language/GML_Reference/Drawing/Colour_And_Alpha/draw_clear_alpha.htm).

* «После отрисовки» вызывается *после* всех стандартных событий отрисовки, но *до* событий «При отрисовке слоя интерфейса». Это удобно, если вы хотите применить пост-обработку или какие-то эффекты ко всей отрисованной сцене, не затрагивая элементы интерфейса.

</details>

<details>
<summary><h2>«При изменении размера окна» [HTML5]</h2></summary>

Это событие относится к категории «При отрисовке», но само не предназначено для отрисовки. Оно используется только в проектах на HTML5, чтобы реагировать на изменение размеров холста. При срабатывании события вы можете прописать код, который будет изменять размеры вида или пересчитывать позиции элементов интерфейса при изменении размера окна браузера.

> **Примечание:** в этом событии **нельзя** выполнять отрисовку! Его цель — только отследить факт изменения размеров холста. Вся отрисовка по-прежнему должна находиться в других событиях отрисовки.

</details>

---

* **назад:** [«События объекта»](Object_Events.htm),
* **далее:** [«Асинхронные события»](Async_Events.htm).